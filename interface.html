<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,700;1,400&family=Roboto:ital,wght@0,300;0,700;1,300&display=swap" rel="stylesheet">
	<style> @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,400;0,700;1,400&family=Roboto:ital,wght@0,300;0,700;1,300&display=swap'); </style>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="style.css">
	<title>JavaLay</title>
</head>
<body>
	<div class="wrapper">

		<header>
			<div class="logo_picter">
			<img class="picter" src="img/main/logo_java.jpg" alt="Logo">
		</div>
		
		<div class="pages">
			<nav><a href="settings.html">Android Studio</a></nav>
			<nav><a href="#" style="color: #fad9ba">Создание интерфейса</a></nav>
			<nav><a href="design.html">UI/UX дизайн</a></nav>
			<nav><a href="example_program.html">Пример приложения</a></nav>
		</div>
			
			<div class="icon">
				<a class="home" href="index.html"><img src="img/main/icon-home.png" alt="Главная"></a>
			</div>
		</header>
		
	<div class="header">
		<h1 style="color:blue">Содержание</h1>
	</div>

		<div class="content">
			<ul>
				<li><a href="#Interface">Графический интерфейс</a></li>
				<li><a href="#ConstraitLayout">ConstraitLayout</a></li>
				<li><a href="#LinearLayout">LinearLayout</a></li>
				<li><a href="#RelativeLayout">RelativeLayout</a></li>
				<li><a href="#TableLayout">TableLayout</a></li>
				<li><a href="#FrameLayout">FrameLayout</a></li>
				<li><a href="#GridLayout">GridLayout</a></li>
				<li><a href="#elements">Основные элементы управления</a></li>
				<ul>

					<li><a href="#TextView">TextView</a></li>
					<li><a href="#EditText">EditText</a></li>
					<li><a href="#Button">Button</a></li>
					<li><a href="#Toast">Toast</a></li>
				</ul>
				<li><a href="#Resource">Работа с ресурсами</a></li>
				<li><a href="#xml">Доступ в файле xml</a></li>
			</ul>
		</div>

		<div class="header">
		<h1>Существует пять стандартных типов верстки</h1>
	</div>

	<img class="image_setting" src="img/interface/diagramma.png" alt="diagramma">
	
	<div class="text">
		<p>
			<p><i>AbsoluteLayout</i> — означает что каждый элемент верстки будет иметь абсолютную позицию относительно верхнего левого угла экрана задаваемую с помощью координат x и y. Т.е. верхний левый угол экрана при AbsoluteLayout имеет координаты x = 0, y = 0. При этом Absolute Layout не рекомендуется использовать из-за его плохой адаптивности.</p>			
			<p><i>FrameLayout</i> — тип верстки, внутри которого может отображаться только один элемент в строке. Т. е. если внутри FrameLayout вы поместите несколько элементов, то следующий будет отображаться поверх предыдущего.</p>	
			<p><i>LinearLayout</i> — тип верстки, при котором область верстки делится на строки и в каждую строку помещается один элемент. Разбиение может быть вертикальное или горизонтальное, тип разбиения указывается в атрибуте LinearLayout android:orientation.</p>	
			<p><i>RelativeLayout</i> — тип верстки, при котором позиционирование элементов происходит относительно друг друга и относительно главного контейнера.</p>	
			<p><i>TableLayout</i> — табличная верстка. Организует элементы в строки и столбцы таблицы.</p>	
			<p><i>Alternate Layouts</i> - альтернативная верстка. Позволяет использовать различную верстку для различных ориентаций экрана. XML для альтернативной верстки помещается в папки проекта:</p>	
			<p><i>res/layout-land</i> - альтернативная верстка для landscape UI.</p>	
			<p><i>res/layout-port</i> - альтернативная верстка для portrait UI.</p>
			<a name="Interface"></a>
			<p><i>res/layout-square</i> - альтернативная верстка для square UI.</p>
			<p>и перед тем, как получить макет из res/layout система проверяет наличие файлов в этих папках.</p>
		</p>
		
		<div class="header">
			<h1>Графический интерфейс</h1>
		</div>
		
		<p>Графический интерфейс пользователя представляет собой иерархию объектов android.view.View и android.view.ViewGroup. Каждый объект ViewGroup представляет контейнер, который содержит и упорядочивает дочерние объекты View. В частности, к контейнерам относят такие элементы, как RelativeLayout, LinearLayout, GridLayout, ConstraintLayout и ряд других.</p>
		
		<p>Простые объекты View представляют собой элементы управления и прочие виджеты, например, кнопки, текстовые поля и т.д., через которые пользователь взаимодействует с программой.</p>
		
		<p>Для работы с визуальными элементами создадим новый проект. В качестве шаблона проекта выберем Empty Activity:</p>
		
		<img class="image_setting" src="img/interface/selection_window.png" alt="selection window">
		
		<p>Пусть он будет называться Booking:</p>
		
		<img class="image_setting" src="img/interface/Booking.png" alt="Booking">
		
		<p>Для лучшего понимания среды Android Studio оно было разделено на 4 части:</p>
		<ol>
			<li>Часть меню: в этом разделе представлены опции для создания нового проекта, открытия существующего проекта Android Studio, кнопка для запуска приложения, выпадающий список для выбора нужного устройства для запуска и тестирования приложения.</li>
			<li>Область верстки: в этом разделе предусмотрено написание кода для таких файлов, как <i>.xml</i>, <i>.java</i>, <i>.kt</i>. Это позволяет открывать несколько файлов одновременно на разных вкладках, но позволяет редактировать по одному файлу за раз.</li>
				<li>Структура проекта: эта область позволяет нам исследовать каждый файл проекта. Существуют различные представления о структуре. Android — это обобщенное представление иерархии структуры проекта, а Project —подробное представление иерархии проекта. Взгляните на следующее изображение.</li>
				<li>Текущая часть выполнения: одна из самых важных частей среды Android Studio. Оно предоставляет подробное представление о текущем выполнении процесса или действия. В нем показано, какие ошибки, выходные данные сборки, результаты logcat и т. д.</li>
			</ol>
			<img class="image_setting" src="img/interface/interface_android_studio.png" alt="interface android studio">
			
			<p>Как правило, для определения визуального интерфейса в проектах под Android используются специальные файлы xml. Эти файлы являются ресурсами разметки и хранят определение визуального интерфейса в виде кода XML. Подобный подход напоминает создание веб-сайтов, когда интерфейс определяется в файлах html, а логика приложения - в коде javascript.</p>
			
			<p>Объявление пользовательского интерфейса в файлах XML позволяет отделить интерфейс приложения от кода. Что означает, что мы можем изменять определение интерфейса без изменения кода java. Например, в приложении могут быть определены разметки в файлах XML для различных ориентаций монитора, различных размеров устройств, различных языков и т.д. Кроме того, объявление разметки в XML позволяет легче визуализировать структуру интерфейса и облегчает отладку.</p>
			
			<p>Файлы разметки графического интерфейса располагаются в проекте в каталоге res/layout. По умолчанию при создании проекта с пустой activity уже есть один файл ресурсов разметки activity_main.xml, который может выглядеть примерно так:</p>
			
			<img class="image_setting" src="img/interface/activity_main.png" alt="activity main">
			<img class="image_setting" src="img/interface/marcup_code.png" alt="marcup code"><br>
		</div>
		
			<div class="table" Brcolor="white">
				<table border="3px">
					<tr>
						<th>Атрибут</th>
						<th>Описание</th>
					</tr>
					<tr>
						<td>android: id</td>
						<td>Идентификатор, который однозначно иденифицирует вид.</td>
					</tr>
		
					<tr>
						<td>android: layout_width</td>
						<td>Ширина макета</td>
					</tr>
					<tr>
						<td>android: layout_height</td>
						<td>Высота макета</td>
					</tr>
					<tr>
						<td>android: layout_marginTop</td>
						<td>Дополнительное пространство на верхней стороне макета.</td>
					</tr>
					<tr>
						<td>android: layout_marginBottom</td>
						<td>Дополнительное пространство в нижней части макета.</td>
					</tr>
					<tr>
						<td>android: layout_marginLeft</td>
						<td>Дополнительное пространство на левой стороне макета.</td>
					</tr>
					<tr>
						<td>android: layout_marginRight</td>
						<td>Дополнительное пространство на правой стороне макета.</td>
					</tr>
					<tr>
						<td>android: layout_gravity</td>
						<td>Определяет, как позиционируются дочерние представления.</td>
					</tr>
					<tr>
						<td>android: layout_weight</td>
						<td>Указывает, сколько дополнительного пространства в макете должно быть выделено для представления.</td>
					</tr>
					<tr>
						<td>android: layout_x</td>
						<td>Определяет X-координату макета.</td>
					</tr>
					<tr>
						<td>android: layout_y</td>
						<td>Определяет Y-координату макета.</td>
					</tr>
					<tr>
						<td>android: paddingLeft</td>
						<td>Заполнение слева для макета.</td>
					</tr>
					<tr>
						<td>android: paddingRight</td>
						<td>Правильный отступ для макета.</td>
					</tr>
					<tr>
						<td>android: paddingTop</td>
						<td>Верхний отступ для макета.</td>
					</tr>
					<tr>
						<td>android: paddingBottom</td>
						<td>Нижний отступ, заполненный для макета.</td>
					</tr>
				</table>
			</div>
		
		<div class="text">
			<p>Здесь ширина и высота – это размерность макета / вида, которая может быть указана в единицах dp (пиксели, не зависящие от плотности), sp (пиксели, не зависящие от масштаба), pt (точки, составляющие 1/72 дюйма), px (Пиксели), мм (миллиметры) и, наконец, в (дюймах).</p>
			
			<p>Вы можете указать ширину и высоту с точными измерениями, но чаще вы будете использовать одну из этих констант для установки ширины или высоты:</p>
			<ul class="marked">
				<li>android: layout_width = wrap_content указывает вашему виду масштабироваться до размеров, требуемых его содержимым.</li>
				<li>android: layout_width = fill_parent говорит о том, что ваше представление становится таким же большим, как и его родительское представление.</li>
				<li>android: layout_width = wrap_content указывает вашему виду масштабироваться до размеров, требуемых его содержимым.</li>
				<li>android: layout_width = fill_parent говорит о том, что ваше представление становится таким же большим, как и его родительское представление.</li>
			</ul>
			<p>Объекту представления может быть присвоен уникальный идентификатор, который будет уникально идентифицировать представление в дереве. Синтаксис для идентификатора внутри тега XML: <i>android:id="@+id/my_button"</i></p>
			
			<p>Символ-символ (@) в начале строки указывает, что анализатор XML должен проанализировать и развернуть оставшуюся часть строки идентификатора и идентифицировать ее как ресурс идентификатора.</p>
			
			<p>Знак плюс (+) означает, что это новое имя ресурса, которое необходимо создать и добавить в наши ресурсы. Чтобы создать экземпляр объекта представления и захватить его из макета, используйте следующее –</p>
			
			<p>Но у нас может быть и несколько различных ресурсов layout. Как правило, каждый отдельный класс Activity использует свой файл layout. Либо для одного класса Activity может использоваться сразу несколько различных файлов layout.</p>
			
			<a name="ConstraitLayout"></a>

			<p>К примеру, добавим в проект новый файл разметки интерфейса. Для этого нажмем на папку <i>res/layout</i> правой кнопкой мыши и в появившемся меню выберем пункт <i>New -> Layout Resource File</i>:</p>
			
			<img class="image_setting" src="img/interface/new_layout_file.png" alt="new layout file">
			
			<div class="header">
				<h1>ConstraintLayout</h1>
			</div>

			
			<div class="text">

				<p>ConstraintLayout представляет контейнер, который позволяет создавать гибкие и масштабируемые визуальные интерфейсы. Для позиционирования элемента внутри ConstraintLayout необходимо указать ограничения (constraints). Есть несколько типов ограничений. Каждое ограничение устанавливает позиционирование элемента либо по горизонтали, либо по вертикали. И для определения позиции элемента в ConstraintLayout необходимо указать как минимум одно ограничение по горизонтали и одно ограничение по вертикали.</p>
				
				<p>Позиционирования может производиться относительно границ самого контейнера ConstraintLayout (в этом случае ограничение имеет значение parent), либо же относительно любого другого элемента внутри ConstraintLayout, тогда в качестве значения ограничения указывается id этого элемента.</p>
				
			<img class="image_setting" src="img/interface/code_example.png" alt="code example">
			
			<p>В данном случае у элемента TextView установлено два ограничение: одно погоризонтальной линии (app:layout_constraintLeft_toLeftOf="parent"), второе - по вертикальной линии (app:layout_constraintTop_toTopOf="parent"). Оба ограничения устанавливаются относительно контейнера ConstraintLayout, поэтому они принимают значение parent, то есть ConstraintLayout.</p>
			
			<p>Ограничение app:layout_constraintLeft_toLeftOf="parent" устанавливает левую границу TextView у левой границы контейнера.</p>
			
			<p>Ограничение app:layout_constraintTop_toTopOf="parent" устанавливает верхнюю границу TextView у верхней границы контейнера.</p>
			
			<p>В итоге TextView будет располагаться в верхнем левом углу контейнера. Стоит обратить внимание, что все эти атрибуты ограничений берутся из пространства имен "http://schemas.android.com/apk/res-auto", которое проецируется на префикс app.</p>
			
			<img class="image_setting" src="img/interface/example_design.png" alt="example design">
			
			<p>Если необходимо установить ограничение относительно другого элемента, то необходимо указать id этого элемента:</p>
			
			<img class="image_setting" src="img/interface/code_example2.png" alt="code example2">
			
			<p>Подобным образом можно составлять различные комбинации атрибутов для определения нужного нам позиционирования. Например, изменим код кнопки:</p>
			
			<img class="image_setting" src="img/interface/code_example3.png" alt="code example3">
			
			<p>В данном случае верхняя граница кнопки выравнивается по нижней границе EditText.</p>
			
			<img class="image_setting" src="img/interface/example_design2.png" alt="example design2">
			
			<p>При разработке приложений под Android мы можем использовать различные типы измерений:</p>
			<ul class="marked">
				<li>px: пиксели текущего экрана. Однако эта единица измерения не рекомендуется, так как реальное представление внешнего вида может изменяться в зависимости от устройства; каждое устройство имеет определенный набор пикселей на дюйм, поэтому количество пикселей на экране может также меняться</li>
				<li>dp: (device-independent pixels) независимые от плотности экрана пиксели. Абстрактная единица измерения, основанная на физической плотности экрана с разрешением 160 dpi (точек на дюйм). В этом случае 1dp = 1px. Если размер экрана больше или меньше, чем 160dpi, количество пикселей, которые применяются для отрисовки 1dp соответственно увеличивается или уменьшается. Например, на экране с 240 dpi 1dp=1,5px, а на экране с 320dpi 1dp=2px. Общая формула для получения количества физических пикселей из dp: px = dp * (dpi / 160)</li>
				<li>sp: (scale-independent pixels) независимые от масштабирования пиксели. Допускают настройку размеров, производимую пользователем. Рекомендуются для работы со шрифтами.</li>
				<li>pt: 1/72 дюйма, базируются на физических размерах экрана</li>
				<li>mm: миллиметры</li>
				<li>in: дюймы</li>
			</ul>
			<p>Предпочтительными единицами для использования являются dp. Это связано с тем, что мир мобильных устройств на Android сильно фрагментирован в плане разрешения и размеров экрана. И чем больше плотность пикселей на дюйм, тем соответственно больше пикселей нам будет доступно.</p>
			
			<p>Все визуальные элементы, которые мы используем в приложении, как правило, упорядочиваются на экране с помощью контейнеров. В Android подобными контейнерами служат такие классы как RelativeLayout, LinearLayout, GridLayout, TableLayout, ConstraintLayout, FrameLayout. Все они по-разному располагают элементы и управляют ими, но есть некоторые общие моменты при компоновке визуальных компонентов, которые мы сейчас рассмотрим.</p>
			
			<p>Для организации элементов внутри контейнера используются параметры разметки. Для их задания в файле xml используются атрибуты, которые начинаются с префикса layout_. В частности, к таким параметрам относятся атрибуты layout_height и layout_width, которые используются для установки размеров и могут использовать одну из следующих опций:</p>
			<ul class="marked">
				<li>Растяжение по всей ширине или высоте контейнера с помощью значения match_parent (для всех контейнеров кроме ConstraintLayout) или 0dp (для ConstraintLayout)</li>
				<li>Растяжение элемента до тех границ, которые достаточны, чтобы вместить все его содержимое с помощью значения wrap_content</li>
				<li>Точные размеры элемента, например, 96 dp</li>
			</ul>
			<p>Установка значения match_parent позволяет растянуть элемент по всей ширине или высоте контейнера. Стоит отметить, что данное значение применяется ко всем контейнерам, кроме ConstraintLayout.</p>
			
			<p>Значение wrap_content устанавливает те значения для ширины или высоты, которые необходимы, чтобы разместить на экране содержимое элемента:</p>
			
			<img class="image_setting" src="img/interface/code_example4.png" alt="code example4">
			
			<p>Здесь элемент TextView растягивается до тех значений, которые достаточны для размещения его текста.</p>
			
			<img class="image_setting" src="img/interface/example_design3.png" alt="example design3">
			
			<p>Также мы можем установить точные значения:</p>
			
			<img class="image_setting" src="img/interface/code_example5.png" alt="code example5">
			
			<p>Кроме того, можно комбинировать несколько значений, например, растянуть по ширине содержимого и установить точные значения для высоты. Параметры разметки позволяют задать отступы как от внешних границ элемента до границ контейнера, так и внутри самого элемента между его границами и содержимым.</p>
			
			<p>Для установки внутренних отступов применяется атрибут android:padding. Он устанавливает отступы контента от всех четырех сторон контейнера. Можно устанавливать отступы только от одной стороны контейнера, применяя следующие атрибуты: android:paddingLeft, android:paddingRight, android:paddingTop и android:paddingBottom.</p>
			
			<img class="image_setting" src="img/interface/example_design4.png" alt="example design4">
			
			<p>Для установки внешних отступов используется атрибут layout_margin. Данный атрибут имеет модификации, которые позволяют задать отступ только от одной стороны: android:layout_marginBottom, android:layout_marginTop, android:layout_marginLeft и android:layout_marginRight (отступы соответственно от нижней, верхней, левой и правой границ).</p>
			
			<a name="LinearLayout"></a>

			<p>Здесь у TextView задаются отступы от двух сторон ConstraintLayout (слева 60 единиц и сверху 50 единиц):</p>
			
			<img class="image_setting" src="img/interface/example_design5.png" alt="example design5">
		</div>
			
		<div class="header">
			<h1>LinearLayout</h1>
		</div>

		<div class="text">

			<p>Контейнер LinearLayout представляет простейший контейнер - объект ViewGroup, который упорядочивает все дочерние элементы в одном направлении: по горизонтали или по вертикали. Все элементы расположены один за другим. Направление разметки указывается с помощью атрибута android:orientation.</p>
			
			<p>Если, например, ориентация разметки вертикальная (android:orientation="vertical"), то все элементы располагаются в столбик - по одному элементу на каждой строке. Если ориентация горизонтальная (android:orientation="horizontal"), то элементы располагаются в одну строку. Например, расположим элементы в горизонтальный ряд:</p>
			
			<img class="image_setting" src="img/interface/code_example6.png" alt="code example6">
			
			<img class="image_setting" src="img/interface/example_design6.png" alt="example design6">
			
			<p>Если бы мы указали для LinearLayout атрибут android:orientation="vertical", то элементы размещались бы по вертикали:</p>
			
			<img class="image_setting" src="img/interface/example_design7.png" alt="example design7">
			
			<a name="RelativeLayout"></a>

			<p>Атрибут layout_gravity позволяет устанавливать позиционирование относительно LinearLayout.</p>
		</div>
		
		<div class="header">
			<h1>RelativeLayout</h1>
		</div>
		<div class="text">
			<a name="TableLayout"></a>
			<p>RelativeLayout представляет объект ViewGroup, который располагает дочерние элементы относительно позиции других дочерних элементов разметки или относительно области самой разметки RelativeLayout. Используя относительное позиционирование, мы можем установить элемент по правому краю или в центре или иным способом, который предоставляет данный контейнер.</p>
		</div>
		
		<div class="header">
			<h1>TableLayout</h1>
		</div>

		<div class="text">
			<p>Контейнер TableLayout структурирует элементы управления в виде таблицы по столбцам и строкам:</p>
			
			<img class="image_setting" src="img/interface/code_example7.png" alt="code example7">
			
			<a name="FrameLayout"></a>
			<img class="image_setting" src="img/interface/example_design8.png" alt="example design8">
		</div>
		
		<div class="header">
			<h1>FrameLayout</h1>
		</div>
		
		<div class="text">
			<a name="GridLayout"></a>
			<p>Контейнер FrameLayout предназначен для вывода на экран одного помещенного в него визуального элемента. Если же мы поместим несколько элементов, то они будут накладываться друг на друга. Тем не менее также можно располагать в FrameLayout несколько элементов.</p>
		</div>
		
		<div class="header">
			<h1>GridLayout</h1>
		</div>

		<div class="text">

			<p>GridLayout представляет еще один контейнер, который позволяет создавать табличные представления. GridLayout состоит из коллекции строк, каждая из которых состоит из отдельных ячеек:</p>
			
			<img class="image_setting" src="img/interface/code_example8.png" alt="code example8">
			
			<p>С помощью атрибутов android:rowCount и android:columnCount устанавливается число строк и столбцов соответственно. Так, в данном случае устанавливаем 3 строки и 3 столбца. GridLayout автоматически может позиционировать вложенные элементы управления по строкам. Так, в нашем случае первая кнопка попадает в первую ячейку (первая строка первый столбец), вторая кнопка - во вторую ячейку и так далее.</p>
			
			<p>При этом ширина столбцов устанавливается автоматически по ширине самого широкого элемента.</p>
			
			<img class="image_setting" src="img/interface/example_design9.png" alt="example design9">
			
			<p>Однако мы можем явно задать номер столбца и строки для определенного элемента, а при необходимости растянуть на несколько столбцов или строк. Для этого мы можем применять следующие атрибуты:</p>
			<ul class="marked">
				<a name="elements"></a>
				<li>android:layout_column: номер столбца (отсчет идет от нуля)</li>
				<li>android:layout_row: номер строки</li>
				<li>android:layout_columnSpan: количество столбцов, на которые растягивается элемент</li>
				<a name="TextView"></a>
				<li>android:layout_rowSpan: количество строк, на которые растягивается элемент</li>
			</ul>
		</div>
	</div>
	
	<div class="header">
		<h1>Основные элементы управления</h1>
	</div>
	
	
	<div class="header">
		<h1><a name="TextView">TextView</a></h1>
	</div>
	
	<div class="text">
		<p>Для простого вывода текста на экран предназначен элемент TextView. Он просто отображает текст без возможности его редактирования.</p>
		<img class="image_setting" src="img/interface/example_design10.png" alt="example_design10"><br>
	</div>

	<div class="table">
		<table border="3px">
			<tr>
				<th>Атрибут</th>
				<th>Описание</th>
			</tr>
			<tr>
				<td>android: text</td>
				<td>Устанавливает текст элемента</td>
			</tr>
			<tr>
				<td>android: textSize</td>
				<td>Устанавливает высоту текста, в качестве единиц измерения для указания высоты используются sp</td>
			</tr>
			<tr>
				<td>android: background</td>
				<td>Задает фоновый цвет элемента в виде цвета в шестнадцатеричной записи или в виде цветового ресурса</td>
			</tr>
			<tr>
				<td>android: textColor</td>
				<td>Задает цвет текста</td>
			</tr>
			<tr>
				<td>android: textAllCaps</td>
				<td>При значении true делает все символы в тексте заглавными</td>
			</tr>
			<tr>
				<td>android: textDirection</td>
				<td>Устанавливает направление текста. По умолчанию используется направление слева направо, <br> но с помощью значения rtl можно установить направление справо налево</td>
			</tr>
			<tr>
				<td>android: textAligment</td>
				<td>Задает выравнивание текста. Может принимать следующие значения:
					<ul>
						<li>center: выравнивание по центру</li>
						<li>textStart: по левому краю</li>
						<li>textEnd: по правому краю</li>
						<a name="EditText"></a>
						<li>viewStart: при направлении текста слева направо выравнивание по левому краю, <br> при направлении справа налево - по правому</li>
						<li>viewEnd: при направлении текста слева направо выравнивание по правому краю, <br> при направлении справа налево - по левому</li>
					</ul>
				</td>
			</tr>
			<tr>
				<td>android: fontFamily</td>
				<td>Устанавливает тип шрифта</td>
			</tr>
		</table>
	</div>
	
	<div class="header">
		<h1>EditText</h1>
	</div>
	
	<div class="text">
		<p>Элемент EditText является подклассом класса TextView. Он также представляет текстовое поле, но теперь уже с возможностью ввода и редактирования текста. Таким образом, в EditText мы можем использовать все те же возможности, что и в TextView.
			Из тех атрибутов, что не рассматривались в теме про TextView, следует отметить атрибут android:hint. Он позволяет задать текст, который будет отображаться в качестве подсказки, если элемент EditText пуст. Кроме того, мы можем использовать атрибут android:inputType, который позволяет задать клавиатуру для ввода.
		</p>
		<img class="image_setting" src="img/interface/code_example9.png" alt="code_example9">
		
		<p>Первое поле здесь обычное однострочное, а второе - многострочное. Чтобы во втором поле текст выравнивался по верху, дополнительно устанавливается атрибут android:gravity="top".</p>
		
		<a name="Button"></a>
		<img class="image_setting" src="img/interface/example_design11.png" alt="example_design11">
		
	</div>
	
	<div class="header">
		<h1>Button</h1>
	</div>
	
	<div class="text">
		<p>Одним из часто используемых элементов являются кнопки, которые представлены классом android.widget.Button. Ключевой особенностью кнопок является возможность взаимодействия с пользователем через нажатия.
			Некоторые ключевые атрибуты, которые можно задать у кнопок:
		</p>
		
		<ul class="marked">
			<li><b>text</b>: задает текст на кнопке</li>
			<li><b>textColor</b>: задает цвет текста на кнопке</li>
			<li><b>background</b>: задает фоновый цвет кнопки</li>
			<li><b>textAllCaps</b>: при значении true устанавливает текст в верхнем регистре. По умолчанию как раз и применяется значение true</li>
			<li><b>onClick</b>: задает обработчик нажатия кнопки</li>
		</ul>
		
		<p>Итак, изменим код в <i>activity_main.xml</i> следующим образом:</p>
		
		<img class="image_setting" src="img/interface/code_example10.png" alt="code_example10">
		
		<p>При помощью атрибута android:onClick можно задать метод в коде java, который будет обрабатывать нажатия кнопки. Так, в вышеприведенном примере это метод sendMessage. Теперь перейдем к коду MainActivity и пропишем в нем такой метод:</p>
		<img class="image_setting" src="img/interface/code_example11.png" alt="code_example11">
		<a name="Toast"></a>
		<p>В данном случае после нажатия на кнопку в TextView выводится текст из EditText.</p>
	</div>

	<div class="header">
		<h1>Toast</h1>
	</div>

	<div class="text">

		<p>
			Для создания простых уведомлений в Android используется класс Toast. Фактически Toast представляет всплывающее окно с некоторым текстом, которое отображается в течение некоторого времени.<br>
		Объект Toast нельзя создать в коде разметки xml, например, в файл activity_main.xml. Toast можно использовать только в коде java.<br>
		Так, определим в файле разметки activity_main.xml кнопку:
	</p>
	
	<img class="image_setting" src="img/interface/code_example12.png" alt="code_example12">
	
	<p>У кнопки установлен обработчик нажатия - метод onClick. Определим его в коде MainActivity:</p>
	
	<img class="image_setting" src="img/interface/code_example13.png" alt="code_example13">
	
	<p>В обработчике отображается всплывающее окно. Для его создания применяется метод Toast.makeText(), в который передается три параметра: текущий контекст (текущий объект activity), отображаемый текст и время отображения окна.
		<br>
		Для самого отображения окна вызывается метод show():
	</p>
	<a name="Resource"></a>
	
	<img class="image_setting" src="img/interface/example_design12.png" alt="example_design12">
</div>

<div class="header">
	<h1>Работа с ресурсами</h1>
</div>

<div class="text">
	<p>Ресурс в приложении Android представляет собой файл, например, файл разметки интерфейса
		или некоторое значение, например, простую строку. То есть ресурсы представляют собой и файлы разметки, и отдельные строки, и звуковые файлы, файлы изображений и т.д.
		 Все ресурсы находятся в проекте в каталоге res. Для различных типов ресурсов, определенных в проекте, в каталоге res создаются подкаталоги. 
		 <br>
		 Поддерживаемые подкаталоги:
		 <ul class="marked">
			<li><b>animator/</b>: xml-файлы, определяющие анимацию свойств</li>
			<li><b>anim/</b>: xml-файлы, определяющие tween-анимацию</li>
			<li><b>color/</b>: xml-файлы, определяющие список цветов</li>
			<li><b>drawable/</b>: Графические файлы (.png, .jpg, .gif)</li>
			<li><b>mipmap/</b>: Графические файлы, используемые для иконок приложения под различные разрешения экранов</li>
			<li><b>layout/</b>: xml-файлы, определяющие пользовательский интерфейс приложения</li>
			<li><b>menu/</b>: xml-файлы, определяющие меню приложения</li>
			<li><b>raw/</b>: различные файлы, которые сохраняются в исходном виде</li>
			<li><b>values/</b>: xml-файлы, которые содержат различные используемые в приложении значения, например, ресурсы строк</li>
			<li><b>xml/</b>: Произвольные xml-файлы</li>
			<a name="xml"></a>
			<li><b>font/</b>: файлы с определениями шрифтом и расширениями .ttf, .otf или .ttc, либо файлы XML, который содержат элемент fontFamily</li>
		 </ul>
	</p>
</div>

<div class="header">
	<h1>Доступ в файле xml</h1>
</div>

<div class="text">
	<p>Нередко возникает необходимость ссылаться на ресурс в файле xml, например, в файле, который определяет визуальный 
		интерфейс, к примеру, в activity_main.xml.
		Ссылки на ресурсы в файлах xml имеют следующую формализованную форму: <br>
		@[имя_пакета:]тип_ресурса/имя_ресурса</p>

		<ul class="marked">
			<li>имя_пакета представляет имя пакета, в котором ресурс находится (указывать необязательно, если ресурс находится в том же пакете)</li>
			<li>тип_ресурса представляет подкласс, определенный в классе R для типа ресурса</li>
			<li>имя_ресурса имя файла ресурса без расширения или значение атрибута android:name в XML-элементе (для простых значений).</li>
		</ul>
</div>
	
	
	<footer>
		<div class="end">
			<p>© 2022 JavaLay</p>
		</div>
		
	</footer>
	
</body>
</html>